
trigger: none

variables:
  team: 'jackalope'  
  projectNumber: 'D201900348.03'
  sitkatechAzureNugetFeed: 'afd3f239-bf1b-4194-b53c-4a5d9e6507d9' #MK 6/4/2024 -- Used to get the fulcrum nuget package from our private feed.

  azureApplicationTFStateResourceGroup: 'esa-$(Environment)'
  TfStateStorageAccountName: 'esatfstate$(Environment)'
  TfStateStorageAccountContainerName: 'kyctg'
  spokeKeyVaultName: 'aks-spoke-kv-esa-$(Environment)'

  resourceGroupName: 'kyctg-$(Environment)'
  appInsightsName: 'kyctg-$(Environment)-insights'
  keyVaultName: 'kyctg-kv-$(Environment)'
  storageAccountName: 'kyctgapp$(Environment)'

  databaseName: 'OregonTilthDB'
  databaseEdition: 'Standard'
  databaseTier: 'ElasticPool'
  sqlApiUsername: 'OregonTilthWeb'
  rabbitMqUser: 'rabbitUser'

  domainApi: 'kyctg-api-v1.esa-$(Environment).sitkatech.com'
  domainWeb2: 'kyctg.esa-$(Environment).sitkatech.com'
  domainWeb3: 'delta-conveyance.esa-$(Environment).sitkatech.com'
  domainWeb4: 'delta-conveyance.aks-$(Environment).sitkatech.com'

resources:
  repositories:
  - repository: self
    type: git
    ref: develop
  - repository: BuildTemplates
    type: github
    name: sitkatech/BuildTemplates
    endpoint: "sitkatech"

    
stages:
- stage: BuildDB
  displayName: Build DB
  jobs:

  - template: azure-pipelines/templates/database/dacpac-template.yml@BuildTemplates 
    parameters:
      name: 'Database'
      solutionFile: 'OregonTilth.Database/OregonTilth.Database.sqlproj'
      additionalArgs: '/p:DSP=Microsoft.Data.Tools.Schema.Sql.SqlAzureV12DatabaseSchemaProvider'
      publishPath: 'OregonTilth.Database/bin/Debug/OregonTilth.Database.dacpac'
      artifactName: 'Database'


- stage: Test
  displayName: Test All
  dependsOn: BuildDB
  condition: and(succeeded(), eq(variables['runTests'], 'true'))
  jobs:  
  - job: Tests
    displayName: 'Tests'
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
      fetchDepth: 0

    - task: AzureKeyVault@2
      inputs:
        azureSubscription: "$(azureSubscription)"
        KeyVaultName: '$(spokeKeyVaultName)'
        SecretsFilter: '*'
        RunAsPreJob: true

    - download: current
      artifact: Database 

    - task: DownloadPipelineArtifact@2
      inputs:
        source: 'specific'
        project: 'OregonTilth'
        pipeline: 'OregonTilthDB Backup Job' # This is the name of the Backup Pipeline in the Project
        runVersion: 'latest'
        artifact: bacpac  
        path: '$(Pipeline.Workspace)/bacpac'
    
    - task: DockerCompose@0
      displayName: 'Start SQL'
      inputs:
        projectName: 'kyctg'
        containerregistrytype: 'Container Registry'
        dockerComposeFile: 'docker-compose/docker-compose-test.yml'
        action: 'Run a Docker Compose command'
        dockerComposeCommand: 'up -d'

    - task: DotNetCoreCLI@2
      displayName: 'dotnet restore'
      inputs:
        command: restore
        projects: 'OregonTilth.Tests/OregonTilth.Tests.csproj'
        feedsToUse: 'select'
        vstsFeed: ${{ variables['sitkatechAzureNugetFeed'] }}
        
    - task: ReplaceTokens@6
      displayName: 'Create Test environment.json'
      inputs:
        root: 'OregonTilth.Tests/'
        sources: 'environment.json.template => environment.json'
        addBOM: true
        escape: 'json'
        missingVarLog: 'error'
        missingVarAction: 'keep'
        tokenPrefix: '#{'
        tokenSuffix: '}#'

    - task: DotNetCoreCLI@2
      displayName: 'dotnet test'
      inputs:
        command: test
        projects: 'OregonTilth.Tests/OregonTilth.Tests.csproj'
        arguments: '--configuration Test --no-restore /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura /p:CoverletOutput=$(Build.SourcesDirectory)/TestResults/Coverage/'
        
    - task: PublishCodeCoverageResults@2
      displayName: 'Publish code coverage report'
      inputs:
        summaryFileLocation: '$(Build.SourcesDirectory)/**/coverage.cobertura.xml'


- stage: BuildWeb
  displayName: Build API/Web
  dependsOn: Test
  condition: |
          and (
            in(dependencies.Test.result, 'Succeeded', 'SucceededWithIssues', 'Skipped'),
            in(dependencies.BuildDB.result, 'Succeeded')
          )
  jobs:
  - job: BuildAPI
    displayName: Build API
    condition: eq(variables['build'], 'true')
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
      fetchDepth: 0

    - task: AzureKeyVault@2
      inputs:
        azureSubscription: "$(azureSubscription)"
        KeyVaultName: '$(spokeKeyVaultName)'
        SecretsFilter: '*'
        RunAsPreJob: true

    - template: azure-pipelines/templates/docker/docker-template.yml@BuildTemplates 
      parameters:
        projectName: 'kyctg'    
        displayName: 'API'
        subscription: '$(azureSubscription)'
        containerRegistry: '$(kv-containerRegistry)'
        dockerComposeFile: 'docker-compose/docker-compose.yml'
        dockerComposeFileArgs: |
          env=$(environment)          
          ESA_NUGET_PAT=$(ESA_NUGET_PAT)
        additionalImageTags: |
          $(Build.BuildNumber)-$(environment)
        includeLatestTag: true


  - job: BuildWeb
    displayName: Build Web
    condition: eq(variables['build'], 'true')
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
      fetchDepth: 0

    - task: AzureKeyVault@2
      inputs:
        azureSubscription: "$(azureSubscription)"
        KeyVaultName: '$(spokeKeyVaultName)'
        SecretsFilter: '*'
        RunAsPreJob: true

    - task: ReplaceTokens@6
      displayName: 'Create .npmrc file to get FormField Package'
      inputs:
        root: 'OregonTilth.Web/'
        sources: '.npmrc.template => .npmrc'
        addBOM: true
        escape: 'off'
        missingVarLog: 'error'
        missingVarAction: 'keep'
        ifNoFilesFound: 'error'
        transforms: false
        tokenPrefix: '#{'
        tokenSuffix: '}#'

    - template: azure-pipelines/templates/docker/docker-template.yml@BuildTemplates 
      parameters:
        projectName: 'kyctg'
        displayName: 'Web'
        subscription: '$(azureSubscription)'
        containerRegistry: '$(kv-containerRegistry)'
        dockerComposeFile: 'OregonTilth.Web/docker-compose/docker-compose.yml'
        dockerComposeFileArgs: 'env=$(environment)'
        additionalImageTags: |
          $(Build.BuildNumber)-$(environment)
        includeLatestTag: true


- stage: BuildTerraform
  displayName: Terraform Plan
  dependsOn: Test
  condition: |
          and (
            in(dependencies.Test.result, 'Succeeded', 'SucceededWithIssues', 'Skipped'),
            in(dependencies.BuildDB.result, 'Succeeded')
          ) 
  jobs:
  - job: Terraform
    displayName: Terraform Plan
    pool:
      vmImage: 'windows-latest'
      demands: msbuild
    steps:
    - checkout: self
      fetchDepth: 0

    - task: AzureKeyVault@2
      inputs:
        azureSubscription: "$(azureSubscription)"
        KeyVaultName: '$(spokeKeyVaultName)'
        SecretsFilter: '*'
        RunAsPreJob: true

    - template: azure-pipelines/templates/terraform/terraform.yml@BuildTemplates 
      parameters: 
        ServiceConnectionName: "$(azureSubscription)"
        TfStateStorageAccountName: "$(tfStateStorageAccountName)"
        TfStateStorageAccountContainerName: "$(TfStateStorageAccountContainerName)"
        TfStateStorageAccountResourceGroup: "$(azureApplicationTfStateResourceGroup)"
        WorkingDirectory: './'
        TerraformCommand: plan
        TerraformCommandOptions: |
          -var "appInsightsName=$(appInsightsName)" 
          -var "keyVaultName=$(keyVaultName)" 
          -var "rabbitMqUser=$(rabbitMqUser)" 
          -var "storageAccountName=$(storageAccountName)" 
          -var "resourceGroupName=$(resourceGroupName)" 
          -var "dbServerName=$(kv-dbServerName)" 
          -var "aspNetEnvironment=$(aspNetEnvironment)" 
          -var "datadogApiKey=$(kv-datadogApiKey)" 
          -var "datadogAppKey=$(kv-datadogAppKey)" 
          -var "domainApi=$(domainApi)" 
          -var "domainWeb=$(domainWeb)" 
          -var "databaseName=$(databaseName)" 
          -var "databaseEdition=$(databaseEdition)" 
          -var "databaseTier=$(databaseTier)" 
          -var "sqlPassword=$(kv-sqlAdministratorPassword)" 
          -var "sqlUsername=$(kv-sqlAdministratorUsername)" 
          -var "azureClusterResourceGroup=$(kv-azureClusterResourceGroup)" 
          -var "databaseResourceGroup=$(kv-databaseResourceGroup)" 
          -var "sqlApiUsername=$(sqlApiUsername)" 
          -var "team=$(team)" 
          -var "projectNumber=$(projectNumber)" 
          -var "elasticPoolName=$(kv-elasticPoolName)" 

  - job: HelmLint
    displayName: Helm Lint
    pool:
      vmImage: 'windows-latest'
      demands: msbuild
    steps:
    - checkout: self
      fetchDepth: 0

    - task: AzureKeyVault@2
      inputs:
        azureSubscription: "$(azureSubscription)"
        KeyVaultName: '$(spokeKeyVaultName)'
        SecretsFilter: '*'
        RunAsPreJob: true
          
    - task: HelmInstaller@0
      displayName: 'Install Helm 3.8.0'
      inputs:
        helmVersion: 3.8.0
        installKubectl: true

    - task: Kubernetes@1
      displayName: 'kubectl login'
      inputs:
        connectionType: Azure Resource Manager
        azureSubscriptionEndpoint: '$(azureSubscription)'
        azureResourceGroup: '$(kv-azureClusterResourceGroup)'
        kubernetesCluster: '$(kv-kubernetesCluster)'
        command: login

    # - task: HelmDeploy@0
    #   displayName: 'helm repo add rabbitmq'
    #   inputs:
    #     connectionType: Azure Resource Manager
    #     azureSubscription: '$(azureSubscription)'
    #     azureResourceGroup: '$(kv-azureClusterResourceGroup)'
    #     kubernetesCluster: '$(kv-kubernetesCluster)'
    #     command: 'repo'
    #     arguments: 'azure-marketplace https://marketplace.azurecr.io/helm/v1/repo'

    - task: HelmDeploy@0
      displayName: 'helm dependency update'
      inputs:
        connectionType: Azure Resource Manager
        azureSubscription: '$(azureSubscription)'
        azureResourceGroup: '$(kv-azureClusterResourceGroup)'
        kubernetesCluster: '$(kv-kubernetesCluster)'
        command: 'dependency'
        arguments: 'update charts/kyctg'

    - task: HelmDeploy@0
      displayName: 'helm lint kyctg'
      inputs:
        connectionType: Azure Resource Manager
        azureSubscription: '$(azureSubscription)'
        azureResourceGroup: '$(kv-azureClusterResourceGroup)'
        kubernetesCluster: '$(kv-kubernetesCluster)'
        namespace: '$(team)'
        arguments: '--with-subcharts charts/kyctg'
        command: lint
        chartType: FilePath
        chartPath: 'charts/kyctg'
        releaseName: 'kyctg'
                
    - task: CopyFiles@2
      inputs:
        sourceFolder: 'charts/kyctg'
        contents: '**'
        targetFolder: $(Build.ArtifactStagingDirectory)/chart
      condition: and(succeeded(), eq(variables['deploy'], 'true'))

    - task: PublishBuildArtifacts@1
      inputs:
        artifactName: ChartArtifacts
        pathtoPublish: $(Build.ArtifactStagingDirectory)
      condition: and(succeeded(), eq(variables['deploy'], 'true'))
  
  
- stage: DeployTerraform
  displayName: Deploy Terraform (with Approval)
  dependsOn: 
    - BuildWeb
    - BuildDB
    - BuildTerraform
  condition: |
    and
    (
      in(dependencies.BuildWeb.result, 'Succeeded', 'SucceededWithIssues'),
      in(dependencies.BuildDB.result, 'Succeeded', 'SucceededWithIssues'),
      in(dependencies.BuildTerraform.result, 'Succeeded', 'SucceededWithIssues'),
      eq(variables['deploy'], 'true')
    )
  jobs:  
  - deployment: Terraform
    pool:
      vmImage: 'windows-latest'
      demands: msbuild
    # creates an environment if it doesn't exist
    environment: '$(Environment)-Approve' # this Environment has an Approval Gate attached to it in the Azure DevOps UI
    strategy:
      # default deployment strategy, more coming...
      runOnce:
        deploy:
          steps:
          - checkout: self
            fetchDepth: 0
                  
          # new
          - template: azure-pipelines/templates/terraform/terraform.yml@BuildTemplates 
            parameters: 
              ServiceConnectionName: "$(azureSubscription)"
              TfStateStorageAccountName: "$(tfStateStorageAccountName)"
              TfStateStorageAccountContainerName: "$(TfStateStorageAccountContainerName)"
              TfStateStorageAccountResourceGroup: "$(azureApplicationTfStateResourceGroup)"
              WorkingDirectory: './'
              TerraformCommand: apply

          - bash: |
              echo "##vso[task.setvariable variable=STORAGE_ACCOUNT_SAS_KEY;isOutput=true]$(TF_OUT_STORAGE_ACCOUNT_SAS_KEY)"
              echo "##vso[task.setvariable variable=APPLICATION_STORAGE_ACCOUNT_KEY;isOutput=true]$(TF_OUT_APPLICATION_STORAGE_ACCOUNT_KEY)"
              echo "##vso[task.setvariable variable=APPLICATION_STORAGE_ACCOUNT_CONNECTION_STRING;isOutput=true]$(TF_OUT_APPLICATION_STORAGE_ACCOUNT_CONNECTION_STRING)"
              echo "##vso[task.setvariable variable=INSTRUMENTATION_KEY;isOutput=true]$(TF_OUT_INSTRUMENTATION_KEY)"
              echo "##vso[task.setvariable variable=SQL_API_PASSWORD;isOutput=true;issecret=true]$(TF_OUT_SQL_API_PASSWORD)"
              echo "##vso[task.setvariable variable=RABBIT_MQ_PASS;isOutput=true;issecret=true]$(TF_OUT_RABBIT_MQ_PASS)"
              echo "##vso[task.setvariable variable=DATABASE_ID;isOutput=true;issecret=true]$(TF_OUT_DATABASE_ID)"
          - bash: 'env | sort'


- stage: RestoreFiles
  displayName: Restore Files
  dependsOn: DeployTerraform
  condition: |
    and
    (
      in(dependencies.DeployTerraform.result, 'Succeeded', 'SucceededWithIssues'),
      eq(variables['restoreFiles'], 'true')
    )
  jobs:  
    - job: RestoreQABlobStorage
      displayName: Restore QA Blob Storage
      pool:
        vmImage: 'windows-latest'
      variables: 
        APPLICATION_STORAGE_ACCOUNT_KEY: $[ stageDependencies.DeployTerraform.Terraform.outputs['Terraform.Bash.APPLICATION_STORAGE_ACCOUNT_KEY'] ]
      steps:
      - template: azure-pipelines/templates/blob-storage-restore/blob-storage-restore.yml@BuildTemplates 
        parameters:
          subscription: '$(azureSubscription)'
          containers: '*'
          fromStorageAccountName: '$(storageAccountProdApplicationName)'
          fromStorageAccountKey: '$(storageAccountProdAccountKey)'
          toStorageAccountName: '$(storageAccountName)'
          toStorageAccountKey: '$(APPLICATION_STORAGE_ACCOUNT_KEY)'


- stage: DeployDB
  displayName: Deploy Database 
  dependsOn: DeployTerraform
  condition: |
    and
    (
      in(dependencies.DeployTerraform.result, 'Succeeded', 'SucceededWithIssues'),
      eq(variables['deploy'], 'true')
    )
  jobs:  
  - deployment: Database
    pool:
      vmImage: 'windows-latest'
      demands: msbuild
    variables: 
      SQL_API_PASSWORD: $[ stageDependencies.DeployTerraform.Terraform.outputs['Terraform.Bash.SQL_API_PASSWORD'] ]
      DATABASE_ID: $[ stageDependencies.DeployTerraform.Terraform.outputs['Terraform.Bash.DATABASE_ID'] ]
    # creates an environment if it doesn't exist
    environment: $(Environment)
    strategy:
      # default deployment strategy, more coming...
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: Database 

          - task: AzureKeyVault@2
            inputs:
              azureSubscription: "$(azureSubscription)"
              KeyVaultName: '$(spokeKeyVaultName)'
              SecretsFilter: '*'
              RunAsPreJob: true
          
          - task: DownloadPipelineArtifact@2
            inputs:
              source: 'specific'
              project: 'OregonTilth'
              pipeline: 'OregonTilthDB Backup Job'
              runVersion: 'latest'
              artifact: bacpac  
              path: '$(Pipeline.Workspace)/bacpac'
            condition: and(succeeded(), eq(variables['restoreDatabase'], true))
          
          - template: azure-pipelines/templates/database/db-deploy-template.yml@BuildTemplates 
            parameters:
              subscription: '$(azureSubscription)'
              serverName: '$(kv-dbServerName).database.windows.net'
              databaseName: '$(databaseName)'
              databaseEdition: '$(databaseEdition)'
              elasticPoolName: '$(kv-elasticPoolName)'
              sqlAdministratorUsername: '$(kv-sqlAdministratorUsername)'
              sqlAdministratorPassword: '$(kv-sqlAdministratorPassword)'
              sqlApiUsername: '$(sqlApiUsername)'
              bacpacFile: '$(Pipeline.Workspace)/bacpac/$(databaseName).bacpac'
              dacpacFile: '$(Pipeline.Workspace)/Database/OregonTilth.Database.dacpac'
              projectResourceGroupName: '$(resourceGroupName)'
              databaseID: '$(DATABASE_ID)'

          - template: azure-pipelines/templates/database/db-user.yml@BuildTemplates 
            parameters:
              subscription: '$(azureSubscription)'
              serverName: '$(kv-dbServerName).database.windows.net'
              databaseName: '$(databaseName)'
              sqlAdministratorUsername: '$(kv-sqlAdministratorUsername)'
              sqlAdministratorPassword: '$(kv-sqlAdministratorPassword)'
              desiredSqlUsername: '$(sqlApiUsername)'
              desiredSqlPassword: '$(SQL_API_PASSWORD)'
              roles: 'db_datawriter,db_datareader'


- stage: DeployHelm
  displayName: Deploy Helm
  dependsOn: 
  - DeployDB
  - DeployTerraform
  condition: |
    and
    (
      in(dependencies.DeployDB.result, 'Succeeded', 'SucceededWithIssues'),
      in(dependencies.DeployTerraform.result, 'Succeeded', 'SucceededWithIssues'),
      eq(variables['deploy'], 'true')
    )
  jobs:  
  - deployment: Helm
    pool:
      vmImage: 'ubuntu-latest'
    variables: 
      APPLICATION_STORAGE_ACCOUNT_KEY: $[ stageDependencies.DeployTerraform.Terraform.outputs['Terraform.Bash.APPLICATION_STORAGE_ACCOUNT_KEY'] ]
      APPLICATION_STORAGE_ACCOUNT_CONNECTION_STRING: $[ stageDependencies.DeployTerraform.Terraform.outputs['Terraform.Bash.APPLICATION_STORAGE_ACCOUNT_CONNECTION_STRING'] ]
      INSTRUMENTATION_KEY: $[ stageDependencies.DeployTerraform.Terraform.outputs['Terraform.Bash.INSTRUMENTATION_KEY'] ]
      SQL_API_PASSWORD: $[ stageDependencies.DeployTerraform.Terraform.outputs['Terraform.Bash.SQL_API_PASSWORD'] ]
      RABBIT_MQ_PASS: $[ stageDependencies.DeployTerraform.Terraform.outputs['Terraform.Bash.RABBIT_MQ_PASS'] ]
    # creates an environment if it doesn't exist
    environment: $(Environment)
    strategy:
      runOnce:
        preDeploy:
          steps:
            - task: AzureKeyVault@2
              inputs:
                azureSubscription: "$(azureSubscription)"
                KeyVaultName: '$(spokeKeyVaultName)'
                SecretsFilter: 'kv-AtlassianClientSecret'
                RunAsPreJob: true

            - template: azure-pipelines/templates/azure-jira-update/update-jira.yml@BuildTemplates 
              parameters: 
                JiraState: "Pending"
                JiraEnvironment: "$(aspNetEnvironment)"
                AtlassianClientSecret: "$(kv-AtlassianClientSecret)"
        on:
          failure:
            steps:
            - task: AzureKeyVault@2
              inputs:
                azureSubscription: "$(azureSubscription)"
                KeyVaultName: '$(spokeKeyVaultName)'
                SecretsFilter: 'kv-AtlassianClientSecret'
                RunAsPreJob: true

            - template: azure-pipelines/templates/azure-jira-update/update-jira.yml@BuildTemplates 
              parameters: 
                JiraState: "Failed"
                JiraEnvironment: "$(aspNetEnvironment)"
                AtlassianClientSecret: "$(kv-AtlassianClientSecret)"
          success: 
            steps:
            - task: AzureKeyVault@2
              inputs:
                azureSubscription: "$(azureSubscription)"
                KeyVaultName: '$(spokeKeyVaultName)'
                SecretsFilter: 'kv-AtlassianClientSecret'
                RunAsPreJob: true

            - template: azure-pipelines/templates/azure-jira-update/update-jira.yml@BuildTemplates 
              parameters: 
                JiraState: "Successful"
                JiraEnvironment: "$(aspNetEnvironment)"
                AtlassianClientSecret: "$(kv-AtlassianClientSecret)"
        deploy:
          steps:
          - task: AzureKeyVault@2
            inputs:
              azureSubscription: "$(azureSubscription)"
              KeyVaultName: '$(spokeKeyVaultName)'
              SecretsFilter: '*'
              RunAsPreJob: true

          - template: azure-pipelines/templates/azure-jira-update/update-jira.yml@BuildTemplates 
            parameters: 
              JiraState: "InProgress"
              JiraEnvironment: "$(aspNetEnvironment)"
              AtlassianClientSecret: "$(kv-AtlassianClientSecret)"

          - download: current
            artifact: ChartArtifacts
              
          - task: HelmInstaller@0
            displayName: 'Install Helm 3.8.0'
            inputs:
              helmVersion: 3.8.0
              installKubectl: true

          - task: Kubernetes@1
            displayName: 'kubectl login'
            inputs:
              connectionType: Azure Resource Manager
              azureSubscriptionEndpoint: '$(azureSubscription)'
              azureResourceGroup: '$(kv-azureClusterResourceGroup)'
              kubernetesCluster: '$(kv-kubernetesCluster)'
              command: login

          # - task: HelmDeploy@0
          #   displayName: 'helm repo add rabbitmq'
          #   inputs:
          #     connectionType: Azure Resource Manager
          #     azureSubscription: '$(azureSubscription)'
          #     azureResourceGroup: '$(kv-azureClusterResourceGroup)'
          #     kubernetesCluster: '$(kv-kubernetesCluster)'
          #     command: 'repo'
          #     arguments: 'azure-marketplace https://marketplace.azurecr.io/helm/v1/repo'

          - task: HelmDeploy@0
            displayName: 'helm dependency update'
            inputs:
              connectionType: Azure Resource Manager
              azureSubscription: '$(azureSubscription)'
              azureResourceGroup: '$(kv-azureClusterResourceGroup)'
              kubernetesCluster: '$(kv-kubernetesCluster)'
              command: 'dependency'
              arguments: 'update $(Pipeline.Workspace)/ChartArtifacts/chart'

          - task: HelmDeploy@0
            displayName: 'helm upgrade kyctg'
            inputs:
              connectionType: Azure Resource Manager
              azureSubscription: '$(azureSubscription)'
              azureResourceGroup: '$(kv-azureClusterResourceGroup)'
              kubernetesCluster: '$(kv-kubernetesCluster)'
              namespace: '$(team)'
              arguments: '--create-namespace'
              command: upgrade
              chartType: FilePath
              chartPath: '$(Pipeline.Workspace)/ChartArtifacts/chart'
              releaseName: 'kyctg'              
              overrideValues: |
                global.env.appInsightsInstrumentationKey="$(INSTRUMENTATION_KEY)"
                global.env.aspNetEnvironment="$(aspNetEnvironment)"
                global.env.emailRedirect="$(emailRedirect)"
                global.domains.web="$(domainWeb)"
                global.env.name="$(Environment)"
                global.env.dbServer=$(kv-dbServerName).database.windows.net
                global.env.databaseName=$(databaseName)
                global.env.sqlUsername=$(sqlApiUsername)
                global.secrets.apiSqlPassword=$(SQL_API_PASSWORD)
                global.secrets.sendGridApiKey="$(kv-sendGridApiKey)"
                global.env.rabbitMqUser=$(rabbitMqUser)
                global.secrets.rabbitMqPass="$(RABBIT_MQ_PASS)"
                global.secrets.blobCS="$(APPLICATION_STORAGE_ACCOUNT_CONNECTION_STRING)"
                rabbitmq.auth.username="$(rabbitMqUser)"
                rabbitmq.auth.password="$(RABBIT_MQ_PASS)"
                kyctg-api.image.repository=$(kv-containerRegistry)/kyctg/api
                kyctg-api.image.tag=$(Build.BuildNumber)-$(environment)
                kyctg-api.ingress.hosts[0]=$(domainApi)
                kyctg-web.image.repository=$(kv-containerRegistry)/kyctg/web
                kyctg-web.image.tag=$(Build.BuildNumber)-$(environment)
                kyctg-web.ingress.hosts[0]=$(domainWeb)
                kyctg-web.ingress.hosts[1]=$(domainWeb2)
                kyctg-web.ingress.hosts[2]=$(domainWeb3)
                kyctg-web.ingress.hosts[3]=$(domainWeb4)
              force: false
                      